"""
MLOps Platform - FastAPI Backend
Main application entry point with webhook endpoints for GitHub integration.
"""

import logging
import os
import tempfile
from pathlib import Path
from typing import Any, Dict, Optional

import git
from fastapi import FastAPI, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# Import new modules
from database import (
    init_supabase, create_model_record, update_model_status, 
    create_deployment_record, ModelStatus, ModelMetadata
)
from model_loader import validate_model_repository, ModelValidationError
from dynamic_api import register_model_api, get_registered_models, ModelDeploymentError
# Configure basic logging for now (will add structlog later)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# FastAPI app initialization
app = FastAPI(
    title="MLOps Platform API",
    description="Automated ML model deployment and monitoring platform",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS middleware for frontend integration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure properly for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models for request/response validation
class GitHubRepository(BaseModel):
    """GitHub repository information from webhook payload."""
    id: int
    name: str
    full_name: str
    clone_url: str
    default_branch: str = "main"

class GitHubCommit(BaseModel):
    """GitHub commit information from webhook payload."""
    id: str
    message: str
    author: Dict[str, Any]
    modified: list[str] = Field(default_factory=list)
    added: list[str] = Field(default_factory=list)

class GitHubWebhookPayload(BaseModel):
    """GitHub webhook payload structure for push events."""
    ref: str
    repository: GitHubRepository
    head_commit: Optional[GitHubCommit] = None
    commits: list[GitHubCommit] = Field(default_factory=list)

class WebhookResponse(BaseModel):
    """Standard response for webhook processing."""
    status: str
    message: str
    model_id: Optional[str] = None
    deployment_url: Optional[str] = None

class ErrorResponse(BaseModel):
    """Standard error response format."""
    error: str
    trace: Optional[str] = None
    timestamp: str

# Custom exceptions
class RepositoryError(Exception):
    """Raised when repository operations fail."""
    pass

class ModelProcessingError(Exception):
    """Raised when model processing fails."""
    pass

# Exception handlers
@app.exception_handler(ModelValidationError)
async def model_validation_exception_handler(request: Request, exc: ModelValidationError):
    logger.error(f"Model validation failed: {str(exc)} for path: {request.url.path}")
    raise HTTPException(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        detail={"error": f"Model validation failed: {str(exc)}", "trace": None}
    )

@app.exception_handler(ModelProcessingError)
async def model_processing_exception_handler(request: Request, exc: ModelProcessingError):
    logger.error(f"Model processing failed: {str(exc)} for path: {request.url.path}")
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail={"error": f"Model processing failed: {str(exc)}", "trace": None}
    )

@app.exception_handler(RepositoryError)
async def repository_exception_handler(request: Request, exc: RepositoryError):
    logger.error("Repository operation failed", error=str(exc), path=request.url.path)
    raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail={"error": f"Repository error: {str(exc)}", "trace": None}
    )

# Core endpoints
@app.get("/", tags=["Health"])
async def root():
    """Health check endpoint."""
    return {"message": "MLOps Platform API is running", "version": "0.1.0"}

@app.get("/health", tags=["Health"])
async def health_check():
    """Detailed health check with system status."""
    # Check Supabase connection
    supabase_status = "connected" if init_supabase() else "disconnected"
    
    return {
        "status": "healthy",
        "version": "0.1.0",
        "services": {
            "api": "running",
            "database": supabase_status,
            "redis": "pending"      # Will be implemented with Celery
        },
        "registered_models": len(get_registered_models())
    }

@app.post("/webhook", response_model=WebhookResponse, tags=["GitHub Integration"])
async def github_webhook(payload: GitHubWebhookPayload):
    """
    GitHub webhook endpoint for handling push events.
    
    This endpoint:
    1. Validates the GitHub push payload
    2. Clones the repository to a temporary directory
    3. Validates the model repository structure
    4. Triggers model validation and deployment (future implementation)
    
    Expected repository structure:
    - model.pkl or model.pt (trained model file)
    - requirements.txt (Python dependencies)
    - predict.py (inference function)
    - test_data.json (sample input for validation)
    """
    logger.info(
        f"Received GitHub webhook for repo: {payload.repository.full_name}, "
        f"ref: {payload.ref}, commit: {payload.head_commit.id if payload.head_commit else 'None'}"
    )
    
    try:
        # Only process pushes to main/master branch
        branch_name = payload.ref.split('/')[-1]
        if branch_name not in ['main', 'master']:
            return WebhookResponse(
                status="skipped",
                message=f"Ignoring push to branch '{branch_name}'. Only main/master branches are processed."
            )
        
        # Clone repository to temporary directory
        repo_url = payload.repository.clone_url
        repo_name = payload.repository.name
        
        cloned_repo_path = await clone_repository(repo_url, repo_name)
        
        # Step 1: Validate repository structure and model
        validation_result = await validate_model_repository(cloned_repo_path)
        
        if not validation_result["structure_valid"]:
            raise ModelValidationError(f"Invalid repository structure: {validation_result['structure_errors']}")
        
        if not validation_result.get("model_validation_passed", False):
            error_msg = validation_result.get("model_validation_error", "Unknown model validation error")
            raise ModelValidationError(f"Model validation failed: {error_msg}")
        
        # Step 2: Create model record in database
        try:
            model_metadata = await create_model_record(
                name=repo_name,
                github_repo=payload.repository.full_name,
                model_file_path=str(cloned_repo_path / validation_result.get("model_file", "model.pkl")),
                predict_file_path=str(cloned_repo_path / "predict.py"),
                requirements_path=str(cloned_repo_path / "requirements.txt"),
                test_data_path=str(cloned_repo_path / "test_data.json")
            )
            
            logger.info(f"Created model record: {model_metadata.id}")
            
        except Exception as e:
            logger.error(f"Failed to create model record: {e}")
            raise ModelProcessingError(f"Failed to create model record: {str(e)}")
        
        # Step 3: Deploy model API
        try:
            # Register dynamic API for this model
            endpoint_url = register_model_api(model_metadata, cloned_repo_path, app)
            
            # Update model status to deployed
            await update_model_status(model_metadata.id, ModelStatus.DEPLOYED)
            
            # Create deployment record
            deployment_record = await create_deployment_record(
                model_id=model_metadata.id,
                endpoint_url=endpoint_url,
                version=model_metadata.version
            )
            
            logger.info(f"Successfully deployed model {model_metadata.id} at {endpoint_url}")
            
        except (ModelDeploymentError, Exception) as e:
            # Update model status to failed
            await update_model_status(model_metadata.id, ModelStatus.FAILED)
            logger.error(f"Failed to deploy model: {e}")
            raise ModelProcessingError(f"Failed to deploy model: {str(e)}")
        
        logger.info(
            f"Successfully processed webhook for {payload.repository.full_name}, "
            f"deployed model {model_metadata.id} at {endpoint_url}"
        )
        
        return WebhookResponse(
            status="success",
            message=f"Model {repo_name} deployed successfully",
            model_id=model_metadata.id,
            deployment_url=endpoint_url
        )
        
    except Exception as e:
        logger.error(
            f"Webhook processing failed for {payload.repository.full_name}: {str(e)}",
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"error": str(e), "trace": type(e).__name__}
        )

# Repository operations
async def clone_repository(repo_url: str, repo_name: str) -> Path:
    """
    Clone a GitHub repository to a temporary directory.
    
    Args:
        repo_url: GitHub clone URL or local file path for testing
        repo_name: Repository name for logging
        
    Returns:
        Path to the cloned repository
        
    Raises:
        RepositoryError: If cloning fails
    """
    try:
        # Create temporary directory for cloned repos
        temp_dir = Path(tempfile.gettempdir()) / "mlops_repos"
        temp_dir.mkdir(exist_ok=True)
        
        # Generate unique directory name
        clone_path = temp_dir / f"{repo_name}_{hash(repo_url) % 10000}"
        
        # Remove existing directory if it exists
        if clone_path.exists():
            import shutil
            shutil.rmtree(clone_path)
        
        # Handle local file URLs for testing
        if repo_url.startswith("file://"):
            local_path = Path(repo_url.replace("file://", ""))
            logger.info(f"Copying local repository {local_path} to {clone_path}")
            
            import shutil
            shutil.copytree(local_path, clone_path)
            
        else:
            # Clone repository
            logger.info(f"Cloning repository {repo_url} to {clone_path}")
            git.Repo.clone_from(repo_url, clone_path, depth=1)
        
        return clone_path
        
    except git.exc.GitCommandError as e:
        raise RepositoryError(f"Failed to clone repository: {e}")
    except Exception as e:
        raise RepositoryError(f"Unexpected error during cloning: {e}")



# Model management endpoints
@app.get("/models", tags=["Models"])
async def list_models():
    """List all deployed models."""
    try:
        registered_models = get_registered_models()
        
        return {
            "models": list(registered_models.values()),
            "total_count": len(registered_models),
            "status": "success"
        }
    except Exception as e:
        logger.error(f"Failed to list models: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"error": f"Failed to list models: {str(e)}", "trace": type(e).__name__}
        )

@app.get("/models/{model_id}", tags=["Models"])
async def get_model_details(model_id: str):
    """Get details for a specific model."""
    try:
        registered_models = get_registered_models()
        
        if model_id not in registered_models:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"error": f"Model {model_id} not found", "trace": None}
            )
        
        model_data = registered_models[model_id]
        
        # Add additional endpoints information
        model_data["endpoints"] = {
            "predict": f"/models/{model_id}/predict",
            "info": f"/models/{model_id}/info", 
            "health": f"/models/{model_id}/health"
        }
        
        return model_data
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get model details: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={"error": f"Failed to get model details: {str(e)}", "trace": type(e).__name__}
        )

# Note: Individual model prediction endpoints are now created dynamically
# via the dynamic_api module. They follow the pattern /models/{model_id}/predict

if __name__ == "__main__":
    import uvicorn
    
    # Development server configuration
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    ) 